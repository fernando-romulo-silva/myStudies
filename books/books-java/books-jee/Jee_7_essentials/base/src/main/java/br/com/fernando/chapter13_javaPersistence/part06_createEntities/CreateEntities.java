package br.com.fernando.chapter13_javaPersistence.part06_createEntities;

import static br.com.fernando.Util.DATA_BASE_SERVER_LOGIN;
import static br.com.fernando.Util.DATA_BASE_SERVER_PASSWORD;
import static br.com.fernando.Util.DATA_BASE_SERVER_PORT;
import static br.com.fernando.Util.EMBEDDED_JEE_TEST_APP_NAME;

import java.io.Serializable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Id;
import javax.persistence.NamedQuery;
import javax.persistence.Query;
import javax.persistence.Table;
import javax.persistence.Transient;

import org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl;
import org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;
import org.myembedded.rdbms.MyEmbeddedRdbms;

import br.com.fernando.chapter13_javaPersistence.part00_intro.HibernatePersistenceUnitInfo;

public class CreateEntities {

    // An entity goes through create, read, update, and delete (CRUD) operations during its life cycle.
    //
    // Typically, an entity is created once, read and updated a few times, and deleted once.
    //
    // The JPA specification outlines the following ways to perform CRUD operations:
    //
    // Java Persistence Query Language (JPQL)
    //
    // The Java Persistence Query Language is a string-based typed query language used to define queries over entities and their persistent state.
    // The query language uses a SQL-like syntax and uses the abstract persistence schema of entities as its data model.
    // This portable query language syntax is translated into SQL queries that are executed over the database schema where the entities are mapped.
    // The EntityManager.createNamedXXX methods are used to create the JPQL statements.
    // The query statements can be used to select, update, or delete rows from the database.
    //
    // Criteria API
    //
    // The Criteria API is an object-based, type-safe API and operates on a metamodel of the entities.
    // Criteria queries are very useful for constructing dynamic queries.
    // Typically, the static metamodel classes are generated by way of an annotation processor, and model the persistent state and relationships of the entities.
    // The javax.persistence.criteria and javax.persistence.metamodel APIs are used to create the strongly typed queries.
    // In JPA 2, the Criteria API allowed only querying the entities.
    // JPA 2.1 allows you to update and delete entities using the Criteria API as well.
    //
    // Native SQL statement
    //
    // Create a native SQL query specific to a database.
    // @SQLResultSetMapping is used to specify the mapping of the result of a native SQL query.
    // The EntityManager.createNativeXXX methods are used to create native queries.
    //
    //
    // @NamedQuery and @NamedQueries are used to define a mapping between a static JPQL query statement and a symbolic name. 
    // This follows the “Don’t Repeat Yourself” (DRY) design pattern and allows you to centralize the JPQL statements:
    @Entity
    @NamedQuery(//
	    name = "findStudent", //
	    query = "SELECT s FROM Student s WHERE p.name = :name" //
    ) //
    @Table(name = "STUDENT")
    public static class Student implements Serializable {

	@Transient
	private static final long serialVersionUID = 1L;

	@Id
	@Column(name = "ID")
	int id;

	@Column(name = "NAME")
	String name;

	@Override
	public String toString() {
	    StringBuilder builder = new StringBuilder();
	    builder.append("Student [id=").append(id).append(", name=").append(name).append("]");
	    return builder.toString();
	}

    }

    // =================================================================================================================================================================
    @SuppressWarnings("unchecked")
    public static void main(final String[] args) throws Exception {

	final String dataBaseName = EMBEDDED_JEE_TEST_APP_NAME + "DB";
	final String dataBaseUrl = "jdbc:hsqldb:hsql://localhost:" + DATA_BASE_SERVER_PORT + "/" + dataBaseName;

	final Properties props = new Properties();
	props.put("javax.persistence.schema-generation.database.action", "create");
	props.put("javax.persistence.jdbc.url", dataBaseUrl);
	props.put("javax.persistence.jdbc.user", DATA_BASE_SERVER_LOGIN);
	props.put("javax.persistence.jdbc.password", DATA_BASE_SERVER_PASSWORD);
	props.put("javax.persistence.jdbc.driver", "org.hsqldb.jdbcDriver");
	// hibernate
	props.put("hibernate.show_sql", "true");
	props.put("hibernate.format_sql", "true");
	props.put("hibernate.use_sql_comments", "true");

	final List<String> classes = Arrays.asList(Student.class.getName());

	try (final MyEmbeddedRdbms embeddedRdbms = new MyEmbeddedRdbms()) {

	    embeddedRdbms.addDataBase(dataBaseName, DATA_BASE_SERVER_LOGIN, DATA_BASE_SERVER_PASSWORD);
	    embeddedRdbms.addSchema("APP", dataBaseName);
	    embeddedRdbms.start(DATA_BASE_SERVER_PORT);

	    final PersistenceUnitInfoDescriptor persistenceUnit = new PersistenceUnitInfoDescriptor(new HibernatePersistenceUnitInfo("appName", classes, props));
	    final EntityManagerFactory factory = new EntityManagerFactoryBuilderImpl(persistenceUnit, new HashMap<>()).build();
	    final EntityManager em = factory.createEntityManager();

	    // -------------------------------------------------------------------------------------------------------

	    em.getTransaction().begin();

	    final Student st1 = new Student();
	    st1.id = 1;
	    st1.name = "Lindsey Craft";

	    final Student st2 = new Student();
	    st2.id = 2;
	    st2.name = "Morgan Philips";
	    
	    final Student st3 = new Student();
	    st3.id = 3;
	    st3.name = "Paul";	    

	    // A new entity can be persisted in the database with an entity manager:
	    em.persist(st1);
	    em.persist(st2);

	    // There is no INSERT statement in JPQL.

	    em.getTransaction().commit();

	    // --------------------------------------------------------------------------------------------------------
	    // You can insert on native query.
	    em.getTransaction().begin();

	    Query query = em.createNativeQuery("INSERT INTO STUDENT (ID, NAME) VALUES (?, ?)");
	    query.setParameter(1, 3);
	    query.setParameter(2, "Mia Xun");
	    query.executeUpdate();
	    // The entity is persisted to the database at the transaction commit.

	    em.getTransaction().commit();
	    // --------------------------------------------------------------------------------------------------------

	    // A simple JPQL statement to query all the Student entities and retrieve the results looks like:
	    List<Student> students = em.createQuery("SELECT s FROM CreateEntities$Student s", Student.class).getResultList();
	    System.out.println(students);
	    
	    // This code will query the database for all the students in grade 4 and return the result as List<Student>.
	    final Query query02 = em.createNamedQuery("findStudent");
	    students = query02 .setParameter("name", "Paul").getResultList();
	    System.out.println(students);

	    em.close();

	    factory.close();
	}
    }

}
