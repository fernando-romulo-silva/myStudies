package br.com.fernando.chapter11_beanValidation.part02_customConstraint;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import javax.enterprise.context.RequestScoped;
import javax.validation.Configuration;
import javax.validation.Constraint;
import javax.validation.ConstraintTarget;
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import javax.validation.ConstraintViolation;
import javax.validation.Payload;
import javax.validation.Valid;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;

public class CustomConstraint {

    // Custom constraints designed to meet specific validation criteria can be defined by the combination of a constraint annotation and
    // a list of custom validation implementations.

    @Documented
    // @Target indicates that this constraint can be declared on types, methods, fields, constructors, and method parameters.
    @Target({ //
            ElementType.ANNOTATION_TYPE, //
            ElementType.METHOD, //
            ElementType.FIELD, //
            ElementType.CONSTRUCTOR, //
            ElementType.PARAMETER //
    })
    @Retention(RetentionPolicy.RUNTIME)

    // @Constraint marks the annotation as a constraint definition. It also creates a link with its constraint validation implementation, defined
    // by the attribute validatedBy. ZipCodeValidator.class provides the validation implementation in this case.
    // Multiple validator implementations may be specified as an array of classes.
    @Constraint(validatedBy = ZipCodeValidator.class)

    // @Size, @Pattern, and @NotNull are primitive constraints used to create this composite custom constraint.
    // Annotating an element with @ZipCode (the composed annotation) is equivalent to annotating it with @Size, @Pattern, and @NotNull
    // (the composing annotations) and @ZipCode.
    //
    // By default, each violation of a composing annotation raises an individual error report.
    //
    // However, @ReportAsSingleViolation on a constraint annotation can be used to suppress the error reports generated by the composing annotations.
    // In this case, the error report from the composed annotation is generated instead.
    //
    @Size(min = 5, message = "{org.sample.zipcode.min_size}")
    @Pattern(regexp = "[0-9]*")
    @NotNull(message = "{org.sample.zipcode.cannot_be_null}")
    public static @interface ZipCode {

        // message value is used to create the error message. In this case, the message value is a resource bundle key that enables internationalization.
        String message() default "{org.sample.zipcode.invalid_zipcode}";

        // group specifies a validation group, which is used to perform partial validation of the bean or control the order in which constraints are evaluated.
        // By default, the value is an empty array and belongs to the Default group.
        Class<?>[] groups() default {};

        // payload is used to associate metadata information with a constraint.
        Class<? extends Payload>[] payload() default {};

        // country is defined as an additional element to parameterize the constraint.
        // The possible set of values for this parameter is defined as an enum with the constraint definition.
        // A default value of the parameter, Country.US, is also specified.
        Country country() default Country.US;

        ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

        public enum Country {

            US,
            CANADA,
            MEXICO,
            INDIA
        }
    }

    // The constraint validator implementation class implements the ConstraintValidator interface.
    // A given constraint can apply to multiple Java types.
    // This requires defining multiple constraint validator implementations, one each for a specific type.
    // This validator can only be applied to string types.
    public static class ZipCodeValidator implements ConstraintValidator<ZipCode, String> {

        List<String> zipcodes;

        // The initialize method initializes any resources or data structures used for validation.
        // This code initializes the array of valid zip codes for a specific country.
        // The values of the country attribute and other attributes are available from the constraintAnnotation parameter.
        // This method is guaranteed to be called before any use of this instance for validation.
        @Override
        public void initialize(final ZipCode constraintAnnotation) {
            System.out.println("ZipCodeValidator.initialize");
            zipcodes = new ArrayList<>();
            switch (constraintAnnotation.country()) {
            case US:
                zipcodes.add("95054");
                zipcodes.add("95051");
                zipcodes.add("94043");
                break;
            case CANADA:
                zipcodes.add("C1A");
                zipcodes.add("M3A");
                zipcodes.add("T4H");
                break;
            case MEXICO:
                zipcodes.add("01020");
                zipcodes.add("08400");
                zipcodes.add("13270");
                break;
            case INDIA:
                zipcodes.add("110092");
                zipcodes.add("400053");
                zipcodes.add("700073");
                break;
            }
        }

        // The isValid method implements the validation logic.
        // The method returns true if the constraint is valid, and false otherwise.
        // The value parameter is the object to validate, and ConstraintValidatorContext provides the context in which the constraint is executed.
        // This methodâ€™s implementation must be thread-safe. This code returns true if the zip code exists in the array of valid zip codes.
        @Override
        public boolean isValid(final String value, final ConstraintValidatorContext context) {
            System.out.println("Validating: " + value);
            System.out.println("state: " + zipcodes.contains(value));
            return zipcodes.contains(value);
        }
    }

    @RequestScoped
    public static class MyBean {

        @ZipCode
        String zip;

        // @ZipCode
        // Long wrongZip;

        public void saveZip(@ZipCode final String zip) {
            System.out.println("Saving zip code for default country (US)");
        }

        public void saveZipIndia(@ZipCode(country = ZipCode.Country.INDIA) final String zip) {
            System.out.println("Saving zip code for India");
        }
    }

    public static class Person {

    }

    @RequestScoped
    public static class AnotherBean {

        // If an instance of AnotherBean is validated, the referenced MyBean object will be validated as well, as the 'myBean' field is annotated with @Valid
        // Therefore the validation of a AnotherBean will fail if the 'zip' field of the referenced MyBean instance is not valid.
        @NotNull
        @Valid
        MyBean myBean;
        //
        // @Valid also provides polymorphic validation. If field Y is an interface or an abstract class, then the validation constraints applied at runtime
        // are from the actual implementing class or subtype.
        //
        // Any Iterable fields and properties may also be decorated with @Valid to ensure all elements of the iterator are validated.
        // @Valid is applied recursively, so each element of the iterator is validated as well:
        @Valid
        List<AnotherBean> beans;

        // In this code, the list of order items is recursively validated along with the orderId field, because @Valid has been specified on items.
        // If @Valid is not specified, only the orderId field is validated when the bean is validated.
        //
        //
        // Some constraints can target the return value as well as its array of parameters. 
        // They are known to be both generic and cross-parameter constraints. 
        // The 'validationAppliesTo' can be used to resolve ambiguity in this case. 
        // Even without ambiguity, it is recommended that you explicitly set validationAppliesTo to ConstraintTarget.PARAMETERS, as it improves readability.
        // The validationAppliesTo attribute can be used to specify the target of the constraint:
        @ZipCode(validationAppliesTo = ConstraintTarget.PARAMETERS)
        public String addPerson(final Person person, final String zip) { // won't validate retun
            // In this code, the ZipCode constraint is applied to method parameters only (i.e., zip parameter in this case).
            //
            return "";
        }
    }

    // ==========================================================================================================================================================
    public static void javaSe() throws Exception {

        final Configuration<?> config = Validation.byDefaultProvider().configure();
        final ValidatorFactory factory = config.buildValidatorFactory(); // Validation.buildDefaultValidatorFactory();
        final Validator validator = factory.getValidator();

        final MyBean bean = new MyBean();

        bean.saveZip("347905334");

        bean.saveZip("3479053575");

        final Set<ConstraintViolation<MyBean>> constraintsViolationBean = validator.validate(bean);

        for (final ConstraintViolation<MyBean> constraintViolationBean : constraintsViolationBean) {

            System.out.println(constraintViolationBean);
        }
    }

    // ==========================================================================================================================================================
    public static void main(final String[] args) throws Exception {
        javaSe();
    }
}
