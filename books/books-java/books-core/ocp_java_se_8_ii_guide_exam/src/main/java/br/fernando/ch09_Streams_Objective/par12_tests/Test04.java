package br.fernando.ch09_Streams_Objective.par12_tests;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

// @SuppressWarnings({ "unused", "rawtypes", "unchecked" })
public class Test04 {

    // =========================================================================================================================================
    static void test01_01() throws Exception {
        // Given the following code:

        List<Integer> al = Arrays.asList(100, 200, 230, 291, 43);

        // Which of the following options will correctly print the number of elements that are less than 200?

        long count = al.stream().filter((i) -> i < 200).count(); // count return a long

        System.out.println(count);

    }

    // =========================================================================================================================================
    static void test01_02() throws Exception {
        boolean result = false;

        // Given:
        List<Integer> ls = Arrays.asList(11, 11, 22, 33, 33, 55, 66);

        // Which of the following expressions will return true?
        //
        result = ls.stream().noneMatch(x -> x % 11 > 0);
        // noneMatch returns true only if none of the elements in the stream satisfy the given Predicate.
        // Here, all the elements are divisible by 11 and x%11 will be 0 for each element.
        // Therefore, the given Predicate will return false for every element, causing noneMatch to return true.
        System.out.println(result);
        //
        // and
        //
        result = ls.stream().distinct().anyMatch(x -> x == 11);
        // anyMatch(Predicate<? super T> predicate) returns whether any elements of this stream match the provided predicate.
        // May not evaluate the predicate on all elements if not necessary for determining the result.
        // If the stream is empty then false is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
        System.out.println(result);
        //
        // Errors
        //
        // ls.stream().anyMatch(44);
        // This will not compile because anyMatch requires a Predicate object as an argument, not an int.
        //
        // ls.stream().distinct().anyMatch(11);
        // This will not compile because anyMatch requires a Predicate object as an argument, not an int.
        //
        // ls.stream().distinct().allMatch(11);
        // This will not compile because anyMatch requires a Predicate object as an argument, not an int.
    }

    // =========================================================================================================================================
    static void test01_03() throws Exception {
        // Which of the following method(s) of java.util.stream.Stream interface is/are used for reduction?

        // collect
        //
        // count
        // Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to:
        // return mapToLong(e -> 1L).sum();
        // This is a terminal operation.

        // The streams classes have multiple forms of general reduction operations, called reduce() and collect(), as well as multiple
        // specialized reduction forms such as sum(), max(), or count().
    }

    // =========================================================================================================================================
    static void test01_04() throws Exception {
        // Given:

        List<Book> books = Arrays.asList(new Book(1, "Book A", "technology", "a1", 10), new Book(2, "Book B", "thriller", "b1", 15));

        // Assuming that books is a List of Book objects, what can be inserted in the code below at DECLARATION and EXPRESSION so that
        // it will classify the books by genre and then also by author?

        // DECLARATION
        Map<String, Map<String, List<Book>>> classified = books.stream() //
                .collect( //
                        Collectors.groupingBy( // EXPRESSION
                                Book::getGenre, Collectors.groupingBy(Book::getAuthor) //
                        ) //
                );

        // Map<String, Map<String, List<Book>>>
        // and
        // Book::getGenre, Collectors.groupingBy(Book::getAuthor)
        //
        // Explanation
        // "classify" implies that you need to create a Map with classifier values as keys and whatever values are generated by the
        // downstream collector as values.
        //
        // Here, we want to have genre names as keys for the top level map. The values of this map will also be Maps with author
        // names as keys and the List of books as values.
        //
        // This declaration and the classification expression correctly achieve the requirement. The following code and its output show a sample:

        books = Arrays.asList(new Book(1, "There is a hippy on the highway", "Thriller", "James Hadley Chase", 15), //
                new Book(2, "Coffin from Hongkong", "Thriller", "James Hadley Chase", 10), //
                new Book(3, "The Client", "Thriller", "John Grisham", 5), //
                new Book(4, "Gone with the wind", "Fiction", "Margaret Mitchell", 40));

        Map<String, Map<String, List<Book>>> classified2 = books.stream() //
                .collect( //
                        Collectors.groupingBy(x -> x.getGenre(), //
                                Collectors.groupingBy(x -> x.getAuthor())));

        System.out.println(classified);
    }

    private static class Book {

        private int id;

        private String title;

        private String genre;

        private String author;

        private double price;

        public Book(String title, double price) {
            super();
            this.title = title;
            this.price = price;
        }

        public Book(int id, String title, String genre, String author, double price) {
            super();
            this.id = id;
            this.title = title;
            this.genre = genre;
            this.author = author;
            this.price = price;
        }

        public int getId() {
            return id;
        }

        public String getGenre() {
            return genre;
        }

        public String getAuthor() {
            return author;
        }

        public double getPrice() {
            return price;
        }

        public String getTitle() {
            return title;
        }

        public void setPrice(double price) {
            this.price = price;
        }
    }

    // =========================================================================================================================================
    static void test01_05() throws Exception {
        // Given Student class
        //
        // What can be inserted in the code below so that it will print:
        // {C=[S3:C], A=[S1:A, S2:A]}

        List<Student> ls = Arrays.asList(new Student("S1", Student.Grade.A), new Student("S2", Student.Grade.A), new Student("S3", Student.Grade.C));

        Map<Student.Grade, List<Student>> grouping = ls.stream().collect(Collectors.groupingBy(s -> s.getGrade()));

        // Explanation
        // This code illustrates the usage of the simplest of the Collectors methods.
        //
        // Collectors.groupingBy(s -> s.getGrade()) returns a Collector that applies a function on the elements of a stream to get a key and
        // then group the elements of the stream by that key into lists.
        //
        // Stream's collect method uses this Collector and returns a Map where the key is the key returned by the function and the value is a
        // List containing all the elements that returned the same key.
        //
        // Here, the function s ->s.getGrade() provides the Grades as the key. The keys returned by this function are, therefore, A, A, and
        // C respectively. Since there are two unique keys (A, C), the Map returned by the collect method will contain
        // two key-value pairs: {C=[S3:C], A=[S1:A, S2:A]}
    }

    static class Student {

        static enum Grade {
            A,
            B,
            C,
            D,
            F
        }

        private final String name;

        private final Grade grade;

        public Student(String name, Grade grade) {
            this.name = name;
            this.grade = grade;
        }

        public Grade getGrade() {
            return grade;
        }

        public String toString() {
            return name + ":" + grade;
        }
    }

    // =========================================================================================================================================
    static void test01_06() throws Exception {
        // What will the following code print when compiled and run?

        List<Integer> iList = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
        Predicate<Integer> p = x -> x % 2 == 0;
        List newList = iList.stream().filter(x -> x > 3).filter(p).collect(Collectors.toList());
        System.out.println(newList);

        // [4, 6]

        // The given code illustrates how you can filter a stream multiple times. The important thing here is that only the elements that 
        // satisfy the filter condition remain in the stream. Rest are eliminated.
        //
        // Here, the first condition (implemented by Predicate p) is that the numbers must be even. This means 1, 3, 5, and 7 are out. 
        // Next, the second condition (specified directly in the call to filter method using lambda expression x->x>3 means that the number 
        // must be greater than 3. This means only 4 and 6 will be left.
    }

    // =========================================================================================================================================
    static void test01_07() throws Exception {
        // Given:
        Stream<String> names = Stream.of("Sarah Adams", "Suzy Pinnell", "Paul Basgall");

        Stream<String> firstNames = names.map(e -> e.split(" ")[0]);

        // public <R> Stream<R> map(Function<? super T,? extends R> mapper) Returns a stream consisting of the results of applying the given
        // function to the elements of this stream.
    }

    // =========================================================================================================================================
    static void test01_08() throws Exception {
        // Assuming that Book has appropriate constructor and accessor methods, what will the following code print?

        List<Book> books = Arrays.asList(new Book("Freedom at Midnight", 5.0), //
                new Book("Gone with the wind", 5.0), //
                new Book("Midnight Cowboy", 15.0));

        books.stream().filter(b -> b.getTitle().startsWith("F")).forEach(b -> b.setPrice(10.0));

        books.stream().forEach(b -> System.out.println(b.getTitle() + ":" + b.getPrice()));

        // Freedom at Midnight:10.0
        // Gone with the wind:5.0
        // Midnight Cowboy:15.0

        // Explanation
        // Filter method removes all the elements for which the given condition (i.e. b.getTitle().startsWith("F")) returns false from the stream.
        // These elements are not removed from the underlying list but only from the stream.
        //
        // Therefore, when you create a stream from the list again, it will have all the elements from the list. Since the setPrice operation
        // changes the Book object contained in the list, the updated value is shown the second time when you go through the list.

    }

    // =========================================================================================================================================
    static void test01_09() throws Exception {
        // Given:
        List<String> l1 = Arrays.asList("a", "b");
        List<String> l2 = Arrays.asList("1", "2");

        // Which of the following lines of code will print the following values?
        // a
        // b
        // 1
        // 2

        Stream.of(l1, l2).flatMap((x) -> x.stream()).forEach((x) -> System.out.println(x));

        // The objective of flatMap is to take each element of the current stream and replace that element with elements contained in
        // the stream returned by the Function that is passed as an argument to flatMap.
        //
        // It is perfect for the requirement of this question. You have a stream that contains Lists.
        //
        // So you need a Function object that converts a List into a Stream of elements. Now, List does have a method named stream()
        // that does just that. It generates a stream of its elements.
        //
        // Therefore, the lambda expression x -> x.stream() can be used here to create the Function object.
    }

    // =========================================================================================================================================
    //
    static void test01_10() throws Exception {

        // Given:
        List<Book> books = Arrays.asList( //
                new Book("Thinking in Java", 30.0), //
                new Book("Java in 24 hrs", 20.0), //
                new Book("Java Recipies", 10.0));

        double averagePrice = books.stream() //
                .filter(b -> b.getPrice() > 10) //
                .mapToDouble(b -> b.getPrice()) //
                .average() // average return a OptionalDouble
                .getAsDouble();

        // What will the following code print? 

        System.out.println(averagePrice);

        // 25.0
    }

    // =========================================================================================================================================
    public static void main(String[] args) throws Exception {
        test01_01();
    }
}
