package org.nandao.cap01.p6using_diamond_operator_constructor_type_inference;

import java.util.ArrayList;
import java.util.List;

public class DiamondOperator {

    public static void main(String[] args) {

    }

    // The use of the diamond operator simplifies the use of generics when creating an object. It
    // avoids unchecked warnings in a program, and it reduces generic verbosity by not requiring
    // explicit duplicate specification of parameter types. Instead, the compiler infers the type.
    // Dynamically-typed languages do this all the time. While Java is statically typed, the use of the
    // diamond operator allows more inferences than before. There is no difference in the resulting compiled code.
    public static void test0() {
        final List<String> list1 = new ArrayList<>();

        final List<String> list2 = new ArrayList(); // Uses raw type

        // Before Java 7, we could address this warning by explicitly using a parameter type as follows:
        final List<String> list3 = new ArrayList<String>();

        System.out.println(list1);
        System.out.println(list2);
        System.out.println(list3);
    }

    // Using the diamond operator when the type is not obvious
    //
    // Type inference is supported in Java 7 and later, only if the parameter type for the constructor
    // is obvious. For example, if we use the diamond operator without specifying a type for the
    // identifier shown as follows, we will get a series of warnings:
    public static void test1() {
        final List arrayList = new ArrayList<>();
        arrayList.add("First");
        arrayList.add("Second");
    }

    // Suppressing unchecked warnings
    //
    // While not necessarily desirable, it is possible to use the @SuppressWarnings annotation
    // to suppress unchecked exceptions generated by the failure to use the diamond operator.
    public static void test2() {
        @SuppressWarnings("unchecked")
        final List<String> arrayList = new ArrayList();
        arrayList.add("First");
        arrayList.add("Second");
    }

    // Understanding erasure
    // Erasure occurs when generics are used. The data type used in the declaration is not available
    // at run-time. This language design decision was made when Java 1.5 introduced generics, to
    // make the code backwards compatible.
    public static void test3() {
        
        // When these methods are compiled, the type information available at compile-time is lost.
        // If we examine the compiled bytecode for these three methods, we will find that there is no
        // difference between them.        
        useRawType();
        useExplicitType();
        useImplicitType();
    }

    private static void useRawType() {
        final List<String> arrayList = new ArrayList();
        arrayList.add("First");
        arrayList.add("Second");
        System.out.println(arrayList.get(0));
    }

    private static void useExplicitType() {
        final List<String> arrayList = new ArrayList<String>();
        arrayList.add("First");
        arrayList.add("Second");
        System.out.println(arrayList.get(0));
    }

    private static void useImplicitType() {
        final List<String> arrayList = new ArrayList<>();
        arrayList.add("First");
        arrayList.add("Second");
        System.out.println(arrayList.get(0));
    }

}
