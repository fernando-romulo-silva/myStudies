package br.fernando.ch14_tests.part06_final.test05_final;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.DoubleFunction;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

// @SuppressWarnings({ "unused", "rawtypes", "unchecked" })
public class Test05_01 {

    // =========================================================================================================================================
    static void test01_01() throws Exception {
        // Which of the following constants are defined in java.nio.file.StandardOpenOption?
        //
        // DSYNC
        // SYNC
        // DELETE_ON_CLOSE
        // SPARSE

        // Error
        // TRUNCATE - TRUNCATE_EXISTING is a valid value but TRUNCATE is not.
    }

    // =========================================================================================================================================
    static void test01_02() throws Exception {
        // What changes, when applied independent of each other, will enable the following code to compile?
        class TestClass {

            public double process(double payment, int rate) {
                double defaultrate = 0.10; // 1

                // if (rate > 10) defaultrate = rate; // 2

                class Implement {

                    public int apply(double data) {
                        Function<Integer, Integer> f = x -> x + (int) (x * defaultrate); // 3
                        return f.apply((int) data); // 4
                    }
                }
                Implement i = new Implement();
                return i.apply(payment);
            }
        }

        // Remove code at //2.
        // A local variable needs to be final or effectively final to be accessed from an inner class or lambda expression.
        // If you remove //2, that means defaultrate never changes and is therefore effectively final.

        // Change //3 to:
        // Function<Integer, Integer> f = x -> x + (int)(x*rate);
    }

    // =========================================================================================================================================
    static void test01_03() throws Exception {
        // Given:
        String sentence1 = "Carpe diem. Seize the day, boys. Make your lives extraordinary.";
        String sentence2 = "Frankly, my dear, I don't give a damn!";
        String sentence3 = "Do I look like I give a damn?";

        List<String> sentences = Arrays.asList(sentence1, sentence2, sentence3);

        // Which of the following options will create a stream containing all the words in the three sentences without repetition?

        Stream<String> strm = sentences.stream() //
                .flatMap(str -> Stream.of(str.split("[ ,.!?\r\n]"))) //
                .filter(s -> s.length() > 0) //
                .distinct();

        // 1. The flatMap method replaces one element of a stream with elements of a new stream generated using the original element.
        // Here, the original elements are the sentences. Each of these elements are replaced in the stream with the elements generated by
        // applying str.split("[ ,.!?\r\n]", which basically converts the stream of sentences into a stream of words.
        //
        // 2. The stream is now filtered and only thoses elements where the length is greater than 0 are allowed to be in the stream.
        //
        // 3. Finally, distinct removes all the duplicates.
    }

    // =========================================================================================================================================
    static void test01_04() throws Exception {
        // Consider the following code fragment appearing in a class:
        final String str = "101";
        final Object obj = "101";

        class Test {

            public int m3(String a, int b) {
                String val = "100";
                Integer iv = 100;
                int i = 100;
                switch (a) {
                case "100":
                    return 1;
                // or
                case str:
                    return 2;

                }
                return 0;
            }
        }

        // Explanation
        //
        // Rule 1 : The type of the switch expression and the type of the case labels must be compatible. In this case, the switch expression
        // is of type String, so all the case labels must be of type String. Therefore, iv, i, obj, and 100 are invalid.
        //
        // Rule 2 : case labels must be compile time constants. Thus, you cannot use non-final variable names as labels.
        // final variables are ok. Therefore, val is invalid.
        //
        // "100" and str both are Strings and are compile time constants and are thus valid.

    }

    // =========================================================================================================================================
    static void test01_05() throws Exception {
        // Which of the following interface definitions can use Lambda expressions?
        //
        // Explanation
        // To take advantage of lambda expressions, an interface must be a "functional" interface, which basically means that the interface must
        // have exactly one abstract method. A lambda expression essentially provides the implementation for that abstract method.
        // It does not matter whether the abstract method is declared in this interface or a super interface.
        //
    }

    interface A {

        default void m1() {
        };

        void m2();
    }

    // =========================================================================================================================================
    static void test01_06() throws Exception {
        // Given that a method named Double getPrice(String id) exists and may potentially return null, about which of the following options
        // can you be certain that a run time exception will not be thrown?

        // 1ยบ
        Optional<Double> price01 = Optional.ofNullable(getPrice("1111"));
        Double x01 = price01.orElse(getPrice("2222"));

        // 2ยบ

        Optional<Double> price02 = Optional.ofNullable(getPrice("1111"));
        Double x02 = price02.orElseGet(() -> getPrice("333"));

        // Optional's orElseGet method takes a java.util.function.Supplier function as an argument and invokes that function to get a value
        // if the Optional itself is empty. Just like the orElse method, this method does not throw any exception even if the Supplier returns null.
        // It does, however, throw a NullPointerException if the Optional is empty and the supplier function itself is null.
    }

    static private Double getPrice(String id) {
        return 0D;
    }

    // =========================================================================================================================================
    static void test01_07() throws Exception {
        // Given the following code:

        // 0x implies the following digits must be interpreted as Hexadecimal digits and b is a valid Hexadecimal digit.
        double x1 = 0xb10_000;

        // A number starting with 0b (or 0B) implies that it is written in binary. Since 10000 can fit into a float, an explicit
        // cast is not required.
        // Note that when you specify the bit pattern using binary or hex, an explicit cast is not required even if the number specified
        // using the bit pattern is larger than what a float can hold.
        float x2 = 0b10_000;

        //
        long x3 = 0b10000L;

        System.out.println(x1 + " " + x2 + " " + x3);

    }

    // =========================================================================================================================================
    static void test01_08() throws Exception {
        // Identify the valid code fragments when occurring by themselves with in a method.
        float f2 = 123_345_667F;
    }

    // =========================================================================================================================================
    static void test01_09() throws Exception {
        // Identify the correct statement about i18n.

        // You should use Locale and formatter objects such as NumberFormat and DateFormat to generate locale specific output.
        //
        // Using default locale for NumberFormat and DateFormat automatically ensures that the formatted text will be localized to the location
        // setting of the machine on which the code is run.
        // (Assuming that default locale hasn't been explicitly changed by any means.)
    }

    // =========================================================================================================================================
    static void test01_10() throws Exception {
        // Which statements about the following code contained in BankAccount.java are correct?

        // It will compile if class BankAccount provides an implementation for getId method.
        //
        // Since interface PremiumAccount redeclares getId method as abstract, the BankAccount class must either provide an implementation for
        // this method or be marked as abstract. In this case, making the class abstract will not help because of
        // the statement - Account acct = new BankAccount();

        class BankAccount implements PremiumAccount {

            @Override
            public String getId() {
                return null;
            }
        }

        Account acct = new BankAccount();
        System.out.println(acct.getId());

    }

    interface Account {

        public default String getId() {
            return "0000";
        }
    }

    interface PremiumAccount extends Account {

        public String getId();
    }

    // =========================================================================================================================================
    static void test01_11() throws Exception {

        // What exception will be thrown out of the main method when the following program is run?

        class Device implements AutoCloseable {

            String header = null;

            public void open() throws IOException {
                header = "OPENED";
                System.out.println("Device Opened");
                throw new IOException("Unknown");
            }

            public String read() throws IOException {
                return "";
            }

            public void close() {
                System.out.println("Closing device");
                header = null;
                throw new RuntimeException("rte");
            }
        }

        try (Device d = new Device()) {
            throw new Exception("test");
        }

        // java.lang.Exception
    }

    // =========================================================================================================================================
    static void test01_12() throws Exception {
        // Which of the following method(s) of java.util.stream.Stream interface is/are used for reduction?
        Stream<String> stream = Stream.of("test1", "test2");

        // reduce
        stream.reduce("", (x, y) -> x.length() > y.length() ? x : y);
        //
        // max
        stream.max((x, y) -> x.length() - y.length());
        // min and max are valid reduction operations. The Stream version of these methods take a Comparator as an argument, while the versions
        // in specialized streams such as IntStream and DoubleStream do not take any argument
    }

    // =========================================================================================================================================
    static void test01_13() throws Exception {
        // Given:

        class Student {

            private String name;

            private int marks;

            public Student(String name, int marks) {
                this.name = name;
                this.marks = marks;
            }

            public String toString() {
                return name + ":" + marks;
            }

            public int getMarks() {
                return marks;
            }
        }

        // What can be inserted in the code below so that it will print:
        // {20=[S1:20, S3:20], 30=[S3:30]}

        List<Student> ls = Arrays.asList(new Student("S1", 20), new Student("S3", 30), new Student("S3", 20));

        Map<Integer, List<Student>> grouping = ls.stream().collect(Collectors.groupingBy(s -> s.getMarks()));
    }

    // =========================================================================================================================================
    static void test01_14() throws Exception {
        // What will the following code fragment print?
        Path p1 = Paths.get("c:\\personal\\.\\photos\\..\\readme.txt");
        Path p2 = p1.normalize();
        System.out.println(p2);

        // c:\personal\readme.txt
        // Notice that . is always redundant and is removed by itself, while .. and the preceding directory cancel each other out
        // because .. means parent directory. For example, a/b/.. is same as a.
    }

    // =========================================================================================================================================
    static void test01_15() throws Exception {
        // Given:
        List<Double> dList = Arrays.asList(10.0, 12.0);
        DoubleFunction df = x -> x + 10;

        // dList.stream().forEach(df); // compilation error here

        dList.stream().forEach(d -> System.out.println(d));

        // A compilation error will occur.
        // forEach method expects a Consumer as an argument. Not a Function.
    }

    // =========================================================================================================================================
    static void test01_16() throws Exception {
        // Which of the following standard functional interfaces returns void?

        // Consumer
        // Its functional method is:
        // void accept(T t)
        // Performs this operation on the given argument.
    }

    // =========================================================================================================================================
    static void test01_17() throws Exception {
        // Consider the directory structure and its contents shown in the figure.
        // (c:\temp is a directory that contains two text files - test1.txt and text2.txt)

        // What should be inserted at //Line 10 in the following code so that it will write "hello" to text2.txt?

        Path p1 = Paths.get("c:\\temp\\test1.txt");
        Path p2 = null; // LINE 10 - INSERT CODE HERE

        BufferedWriter bw = new BufferedWriter(new FileWriter(p2.toFile()));
        bw.write("hello");
        bw.close();

        p2 = p1.resolveSibling("text2.txt");
    }

    // =========================================================================================================================================
    static void test01_18() throws Exception {
	// What will the following code print when compiled and run?
        class Names {

            private List<String> list;

            public List<String> getList() {
                return list;
            }

            public void setList(List<String> list) {
                this.list = list;
            }

            public void printNames() {
                System.out.println(getList());
            }
        }

        List<String> list = Arrays.asList("Bob Hope", "Bob Dole", "Bob Brown");

        Names n = new Names();

        n.setList(list.stream().collect(Collectors.toList()));
        // n.getList().forEach(Names::printNames); compilation error here
        //
        // Compilation error
        // Observe that the method printNames does not take any argument. But the argument for forEach method requires a method that takes 
        // an argument. The forEach method basically invokes the passed method and gives that method an element of the list as an argument. 
    }

    // =========================================================================================================================================
    static void test01_19() throws Exception {
        // Which functional interface(s) would you use if you need a function that always returns the same type as the type of its input(s)?

        // UnaryOperator
        // public interface UnaryOperator<T> extends Function<T,T>
        // Represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of 
        // Function for the case where the operand and result are of the same type.
        //
        // BinaryOperator
        // public interface BinaryOperator<T> extends BiFunction<T,T,T>
        // Represents an operation upon two operands of the same type, producing a result of the same type as the operands. 
        // This is a specialization of BiFunction for the case where the operands and the result are all of the same type. 
        // This is a functional interface whose functional method is BiFunction.apply(Object, Object).
    }

    // =========================================================================================================================================
    //
    static void test01_20() throws Exception {

    }

    // =========================================================================================================================================
    public static void main(String[] args) throws Exception {
        test01_01();
    }
}
