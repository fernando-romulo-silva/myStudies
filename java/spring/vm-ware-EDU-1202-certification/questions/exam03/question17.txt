Which of the following transaction propagation behaviour use the current transaction if there is one?
  ​
A)
NEVER
​
B)
MANDATORY
​
C)
REQUIRED
​
D)
SUPPORTS
   








































Answers 'B' 'C' and 'D'

All of these use the current transaction if there is one except for NEVER, which never uses transactions. 

	// Outside a transaction context:
	// The interceptor must begin a new JTA transaction, the managed bean method execution must then continue inside this transaction context,
	// and the transaction must be completed by the interceptor
	//
	// Inside a transaction context:
	// The current transaction context must be suspended, a new JTA transaction will begin, the managed bean method execution must then continue
	// inside this transaction context, the transaction must be completed, and the previously suspended transaction must be resumed.
	@Transactional(Transactional.TxType.REQUIRED) // (Default)
	public void required() {
	    System.out.println(getClass().getName() + "Transactional.TxType.REQUIRED");
	}

	// Outside a transaction context:
	// A TransactionalException with a nested TransactionRequiredException must be thrown.
	//
	// Inside a transaction context:
	// The managed bean method execution will then continue under that context.
	@Transactional(Transactional.TxType.MANDATORY)
	public void mandatory() {
	    System.out.println(getClass().getName() + "Transactional.TxType.MANDATORY");
	    // Here the container will allow only clients that already startd a transaction to call this method
	}

	// Outside a transaction context:
	//
	// Inside a transaction context:
	@Transactional(Transactional.TxType.SUPPORTS)
	public void supports() {
	    System.out.println(getClass().getName() + "Transactional.TxType.SUPPORTS");
	    // Here the container will allow the method to be called by a client whether the client already has a transaction or not
	}

	// Outside a transaction context:
	// The managed bean method execution must then continue outside a transaction context.
	//
	// Inside a transaction context:
	// The managed bean method execution must then continue inside this transaction context.
	@Transactional(Transactional.TxType.REQUIRES_NEW)
	public void requiresNew() {
	    System.out.println(getClass().getName() + "Transactional.TxType.REQUIRES_NEW");
	    // Here the container will always start a new transaction and run the method inside its scope
	}

	// Outside a transaction context:
	// The managed bean method execution must then continue outside a transaction context.
	//
	// Inside a transaction context:
	// The current transaction context must be suspended, the managed bean method execution must then continue outside a transaction context,
	// and the previously suspended transaction must be resumed by the interceptor that suspended it after the method execution has completed.
	@Transactional(Transactional.TxType.NOT_SUPPORTED)
	public void notSupported() {
	    System.out.println(getClass().getName() + "Transactional.TxType.NOT_SUPPORTED");
	    // Here the container will make sure that the method will run in no transaction scope and will suspend any transaction started by the client
	}

	// Outside a transaction context:
	// The managed bean method execution must then continue outside a transaction context.
	//
	// Inside a transaction context:
	// A TransactionalException with a nested InvalidTransactionException must be thrown.
	@Transactional(Transactional.TxType.NEVER)
	public void never() {
	    System.out.println(getClass().getName() + "Transactional.TxType.NEVER");
	    // Here the container will reject any invocation done by clients already participate in transactions
	}

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html





 