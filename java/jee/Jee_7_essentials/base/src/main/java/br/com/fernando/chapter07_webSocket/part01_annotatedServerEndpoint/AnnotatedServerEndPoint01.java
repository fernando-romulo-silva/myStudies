package br.com.fernando.chapter07_webSocket.part01_annotatedServerEndpoint;

import static br.com.fernando.Util.APP_FILE_TARGET;
import static br.com.fernando.Util.EMBEDDED_JEE_TEST_APP_NAME;
import static br.com.fernando.Util.HTTP_PORT;
import static br.com.fernando.Util.connectToServerWebSockets;
import static br.com.fernando.Util.downVariables;
import static br.com.fernando.Util.startVariables;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import javax.websocket.ClientEndpoint;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.PongMessage;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;

import org.myembedded.jeecontainer.MyEmbeddedJeeContainer;
import org.myembedded.pack.EmbeddedResource;
import org.myembedded.pack.EmbeddedWar;

public class AnnotatedServerEndPoint01 {

    // =================================================================================================================================================================
    // You can convert a Plain Old Java Object (POJO) into a WebSocket server endpoint by using @ServerEndpoint.
    // Such an endpoint is also called an annotated endpoint:
    @ServerEndpoint("/text")
    // @ServerEndpoint decorates the class as a WebSocket endpoint published at the URI mentioned as a value of the annotation.
    // @ServerEndpoint attributes:
    // > value = Required URI or URI template where the endpoint will be deployed.
    // > encoders = Optional ordered array of encoders used by this endpoint.
    // > decoders = Optional ordered array of decoders used by this endpoint.
    // > subprotocols = Optional ordered array of WebSocket protocols supported by this endpoint.
    // > configurator = Optional custom configurator class used to further configure new instances of this endpoint.
    // This will be an implementation of ServerEndpointConfig.Configurator .
    //
    // The annotated class must have a public no-arg constructor.
    public static class MyEndpointText {

        // @OnMessage decorates a Java method that receives the incoming WebSocket message. This message can process text, binary, and pong messages.
        // The text and binary messages contain the payload generated by the application.
        // A pong message is a WebSocket control message and is generally not dealt with at the application layer.
        //
        //
        @OnMessage
        public String receiveMessage(String name, Session session) { // you can put the session, it'll be inject!
            System.out.println("My Name is " + name);

            Map<String, Object> map = session.getUserProperties();
            Integer count = 0;
            if (map.get("count") != null) {
                count = (Integer) map.get("count");
            }
            System.out.format("Called %d times", ++count);
            System.out.println("");
            map.put("count", count);

            return name;
        }

        // — Use a Java primitive or class equivalent to receive the whole message converted to that type:
        // @OnMessage
        public void receiveMessage(int i) {
            // . . .
        }

        // — Use a String and a boolean pair to receive the message in parts (Partial Messages)
        // (The Boolean parameter is true if the part received is the last part, and false otherwise).:
        // @OnMessage
        public void receiveBigText(String message, boolean last) {
            // . . .
        }

        // — Use a Reader to receive the whole text message as a blocking stream:
        // — Use any object parameter for which the endpoint has a text decoder ( Decoder.Text or Decoder.TextStream )—more on this later.
        // @OnMessage
        public void processReader(Reader reader) {
            // . . .
        }

        // If the method is handling binary messages:
        // — Use byte[] or ByteBuffer to receive the whole binary message:
        // @OnMessage
        public void receiveMessage(ByteBuffer b) {
            // . . .
        }

        // — Use byte[] and a boolean pair, or ByteBuffer and a boolean pair, to receive the message in parts,
        // the Boolean parameter is true if the part received is the last part, and false otherwise.
        // @OnMessage
        public void receiveBigBinary(ByteBuffer buf, boolean last) {
            // . . .
        }

        // — Use InputStream to receive the whole binary message as a blocking stream.
        // Use any object parameter for which the endpoint has a binary decoder ( Decoder.Binary or Decoder.BinaryStream ):
        // @OnMessage
        public void processStream(InputStream stream) {
            // . . .
        }

        // If the method is handling pong messages:
        // — Use PongMessage to receive the pong message:
        // @OnMessage
        public void processPong(PongMessage pong) {
            // . . .
        }

        // Float
        // @OnMessage
        public float echoFloat(Float f) {
            System.out.println("echoFloat");
            return f;
        }
    }

    // The WebSocket annotation behaviors are not passed down the Java class inheritance hierarchy. 
    // They apply only to the Java class on which they are marked. 
    // For example, a Java class that inherits from a Java class annotated with a class-level @ServerEndpoint annotation does not itself become 
    // an annotated endpoint, unless it itself is annotatedwith a class-level @ServerEndpoint annotation.

    @ClientEndpoint
    public static class MyEndpointTextClient {

        public static CountDownLatch latch = new CountDownLatch(1);

        public static String response;

        @OnOpen
        public void onOpen(final Session session) {
            try {
                // Send the message to endpoint
                session.getBasicRemote().sendText("Hello World!");
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }

        @OnMessage
        public void processMessage(final String message) {
            response = message;
            latch.countDown();
        }
    }

    // =================================================================================================================================================================
    @ClientEndpoint
    public static class MyEndpointByteArrayClient {

        public static CountDownLatch latch = new CountDownLatch(1);

        public static byte[] response;

        @OnOpen
        public void onOpen(Session session) {
            try {
                session.getBasicRemote().sendBinary(ByteBuffer.wrap("Hello World!".getBytes()));
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }

        @OnMessage
        public void processMessage(byte[] message) {
            response = message;
            latch.countDown();
        }
    }

    @ServerEndpoint("/bytearray")
    public static class MyEndpointByteArray {

        @OnMessage
        public byte[] echoBinary(byte[] data) throws IOException {
            return data;
        }
    }

    // =================================================================================================================================================================
    @ClientEndpoint
    public static class MyEndpointByteBufferClient {

        public static CountDownLatch latch = new CountDownLatch(1);

        public static byte[] response;

        @OnOpen
        public void onOpen(Session session) {
            try {
                session.getBasicRemote().sendBinary(ByteBuffer.wrap("Hello World!".getBytes()));
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }

        @OnMessage
        public void processMessage(byte[] message, boolean last) {
            System.out.println("boolean(binary) " + message);
            System.out.println("binary length " + message.length);

            response = message;
            latch.countDown();
        }
    }

    @ServerEndpoint("/bytebuffer")
    public static class MyEndpointByteBuffer {

        @OnMessage
        public ByteBuffer echoBinary(byte[] data) throws IOException {
            System.out.println("echoBinary");
            return ByteBuffer.wrap(data);
        }
    }

    // =================================================================================================================================================================
    @ClientEndpoint
    public static class MyEndpointInputStreamClient {

        public static CountDownLatch latch = new CountDownLatch(1);

        public static byte[] response;

        @OnOpen
        public void onOpen(Session session) {
            try {
                session.getBasicRemote().sendBinary(ByteBuffer.wrap("Hello World!".getBytes()));
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }

        @OnMessage
        public void processMessage(byte[] message) {
            response = message;
            latch.countDown();
        }
    }

    @ServerEndpoint("/inputstream")
    public static class MyEndpointInputStream {

        @OnMessage
        public void echoStream(InputStream stream, Session session) throws IOException {
            System.out.println("echoStream: " + stream);
            byte[] b = new byte[12];
            stream.read(b);
            session.getBasicRemote().sendBinary(ByteBuffer.wrap(b));
        }
    }

    // ==================================================================================================================================================================
    public static void main(String[] args) throws Exception {
        startVariables();

        try (final MyEmbeddedJeeContainer embeddedJeeServer = new MyEmbeddedJeeContainer();) {

            final EmbeddedWar war = new EmbeddedWar(EMBEDDED_JEE_TEST_APP_NAME);

            war.addClasses( //
                    MyEndpointText.class, //
                    MyEndpointTextClient.class, //
                    MyEndpointByteArray.class, //
                    MyEndpointByteArrayClient.class, //
                    MyEndpointByteBuffer.class, //
                    MyEndpointByteBufferClient.class, //
                    MyEndpointInputStream.class, //
                    MyEndpointInputStreamClient.class);

            war.addWebResourceFiles(EmbeddedResource.add("src/main/resources/chapter07_webSocket/part01_annotedServerEndpoint/pathParam.jsp"));
            war.addWebResourceFiles(EmbeddedResource.add("src/main/resources/chapter07_webSocket/part01_annotedServerEndpoint/pathParam.js"));

            final File warFile = war.exportToFile(APP_FILE_TARGET);

            embeddedJeeServer.start(HTTP_PORT);
            embeddedJeeServer.deploy(EMBEDDED_JEE_TEST_APP_NAME, warFile.getAbsolutePath());

            // --------------------------------------------------------------------------------------------------------------------------------
            // MyEndpointTextClient
            connectToServerWebSockets(MyEndpointTextClient.class, "text");
            MyEndpointTextClient.latch.await(3, TimeUnit.SECONDS);
            System.out.println("MyEndpointText :" + MyEndpointTextClient.response);

            // --------------------------------------------------------------------------------------------------------------------------------
            // MyEndpointByteBufferClient
            connectToServerWebSockets(MyEndpointByteBufferClient.class, "bytebuffer");
            MyEndpointByteBufferClient.latch.await(3, TimeUnit.SECONDS);
            System.out.println("MyEndpointByteBufferClient :" + MyEndpointByteBufferClient.response);

            // --------------------------------------------------------------------------------------------------------------------------------
            // MyEndpointByteArrayClient
            connectToServerWebSockets(MyEndpointByteArrayClient.class, "bytearray");
            MyEndpointByteArrayClient.latch.await(3, TimeUnit.SECONDS);
            System.out.println("MyEndpointByteArrayClient :" + MyEndpointByteArrayClient.response);

            // --------------------------------------------------------------------------------------------------------------------------------
            // MyEndpointInputStreamClient
            connectToServerWebSockets(MyEndpointInputStreamClient.class, "inputstream");
            MyEndpointInputStreamClient.latch.await(3, TimeUnit.SECONDS);
            System.out.println("MyEndpointInputStreamClient :" + MyEndpointInputStreamClient.response);

        } catch (final Exception ex) {
            System.out.println(ex);
        }

        downVariables();
    }
}
